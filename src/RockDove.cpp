//
// RockDove.cpp
// 
// Description: RockDove mailer utility. This program allows to send massive emails
// to some address stored in MySql ROCKDB in the table ADDRESS. 
// It is a command line program and the syntax is:
// #rockdove [-vh] -i:HTMLFilename -c:ConfFile
// where:
// -v displays all the records to be processed
// -h displays an help
// -i use HTMLFile as a file to send to all addresses. This parameter is mandatory
// -c use ConfFile as a config file. The config file looks like this:
// 
// SMTPHostname = smtp.gmail.com
// SMTPPort = 587
// Username = valid_user@gmail.com
// Password = password
// FromAddress = valid_user@gmail.com
//
// *******************************************************************************
//
// Permission is hereby granted, free of charge, to any person or organization
// obtaining a copy of the software and accompanying documentation covered by
// this license (the "Software") to use, reproduce, display, distribute,
// execute, and transmit the Software, and to prepare derivative works of the
// Software, and to permit third-parties to whom the Software is furnished to
// do so, all subject to the following:
// 
// The copyright notices in the Software and this entire statement, including
// the above license grant, this restriction and the following disclaimer,
// must be included in all copies of the Software, in whole or in part, and
// all derivative works of the Software, unless such copies or derivative
// works are solely in the form of machine-executable object code generated by
// a source language processor.
// 
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
// SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
// FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
// DEALINGS IN THE SOFTWARE.

#include <Poco/Logger.h>
#include <Poco/PatternFormatter.h>
#include <Poco/FormattingChannel.h>
#include <Poco/ConsoleChannel.h>
#include <Poco/FileChannel.h>
#include <Poco/Format.h>
#include <Poco/Message.h>
#include <Poco/Data/Common.h>
#include <Poco/Data/MySQL/Connector.h>
#include <Poco/Data/RecordSet.h>
#include <Poco/Util/Application.h>
#include <Poco/Util/Option.h>
#include <Poco/Util/OptionSet.h>
#include <Poco/Util/HelpFormatter.h>
#include <Poco/Util/PropertyFileConfiguration.h>
#include <Poco/Net/MailMessage.h>
#include <Poco/Net/MailRecipient.h>
#include <Poco/Net/SMTPClientSession.h>
#include <Poco/Net/SecureSMTPClientSession.h>
#include <Poco/Net/StringPartSource.h>
#include <Poco/Net/Context.h>
#include <Poco/Net/SecureStreamSocket.h>
#include <Poco/Net/SSLManager.h>
#include <Poco/Net/ConsoleCertificateHandler.h>
#include <Poco/Net/KeyConsoleHandler.h>
#include <Poco/StreamCopier.h>
#include <Poco/FileStream.h>
#include <Poco/File.h>
#include <Poco/AutoPtr.h>
#include <Poco/SplitterChannel.h>
#include <Poco/SimpleFileChannel.h>
#include <iostream>

using namespace Poco::Data;
using namespace std;

using Poco::Util::Application;
using Poco::Util::Option;
using Poco::Util::OptionSet;
using Poco::Util::HelpFormatter;
using Poco::Util::OptionCallback;
using Poco::Util::PropertyFileConfiguration;
using Poco::Net::MailMessage;
using Poco::Net::MailRecipient;
using Poco::Net::SMTPClientSession;
using Poco::Net::SecureSMTPClientSession;
using Poco::Net::StringPartSource;
using Poco::Net::SSLManager;
using Poco::Net::KeyConsoleHandler;
using Poco::Net::PrivateKeyPassphraseHandler;
using Poco::Net::InvalidCertificateHandler;
using Poco::Net::ConsoleCertificateHandler;
using Poco::Net::Context;
using Poco::AutoPtr;
using Poco::Util::PropertyFileConfiguration;
using Poco::SplitterChannel;
using Poco::ConsoleChannel;
using Poco::SimpleFileChannel;
using Poco::Logger;
using Poco::FormattingChannel;
using Poco::Logger;
using Poco::PatternFormatter;
using Poco::FileChannel;
using Poco::Message;
using Poco::SharedPtr;




#include "RockDove.h"


//RockDove::RockDove(const std::string& db, RockDoveLogger& log) :
//		rDB	(db),
//		mLog (log)	
RockDove::RockDove(const std::string& db) :
		rDB	(db)
{
}

RockDove::~RockDove()
{
}

int RockDove::DisplayRecords()
{

	//mLog.LogInformation("Initializating DB connection");
	RockDove::InitDB();
	


	try
	{

		// Connection to DB
		//mLog.LogInformation("Connecting to DB");
		
		const std::string conn_str = "user=root;password=marco;db=" + rDB + ";compress=false;auto-reconnect=true";	
		Session sess("MySQL", conn_str);
		
		// Counting records
		//mLog.LogInformation("Select count from ADDRESS");
        int count = 0;
        sess << "select count(*) from ADDRESS", into(count), now;

	    // Retreiving records
		//mLog.LogInformation("retreiving records");
		std::vector<std::string> data, name, surname;
        sess << "select name, surname, email from ADDRESS", into(name), into(surname), into(data), now;

		// Displaying records
		//mLog.LogInformation("Displaying records");
		for(unsigned int i=0; i < data.size(); i++){
			std::cout << "	email record #" << i << "/" << count << ", " << name[i] << " " << surname[i] << " " << data[i] << std::endl;
			//mLog.LogInformation(Poco::format("email record # %d/%d %s %s %s", i+1, count, name[i], surname[i], data[i]));
		}
		
		//mLog.LogInformation(Poco::format("%d records displyed", count));
        std::cout << "\nRecords displayed." << std::endl;
		
		
	}
	
	catch (Poco::Exception& exc)
	{
		//mLog.LogError(Poco::format("Error found in executing display query: %s", exc.displayText()));
		return -1;
	}
	
	//mLog.LogInformation("Closing DB");
	RockDove::ShutdownDB();
	
	return 0;
}

int RockDove::SendAllMails(RockDoveMailer& m)
{

	//mLog.LogInformation("Initializating DB connection");
	RockDove::InitDB();
	


	try
	{

		// Connection to DB
		//mLog.LogInformation("Connecting to DB");
		
		const std::string conn_str = "user=root;password=marco;db=" + rDB + ";compress=false;auto-reconnect=true";	
		Session sess("MySQL", conn_str);
		
		// Counting records
		//mLog.LogInformation("Select count from ADDRESS");
        int count = 0;
		int max_rec = 0;
        sess << "select count(*) from ADDRESS", into(count), now;

		// Retreiving records
		//mLog.LogInformation("retreiving records");		
	    std::vector<std::string> data, name, surname;
        sess << "select email from ADDRESS", into(data), now;

		// Sending emails
		//mLog.LogInformation("Sending emails");
		max_rec = count;
		for(unsigned int i=0; i < data.size(); i++){
			std::cout << "Sending email for record #" << i << "/" << max_rec << " to address: " << data[i] << std::endl;
			//mLog.LogInformation(Poco::format("Sending email for record # %d/%d %s %s %s", i+1, count, name[i], surname[i], data[i]));
			try 
			{
				m.SendMail(data[i]);
			}
			catch (Poco::Exception& exc)
			{
				//mLog.LogError(Poco::format("Error sending record # %d : %s", i+1, exc.displayText()));
			}
		}

		
		
	}
	
	catch (Poco::Exception& exc)
	{
		//mLog.LogError(Poco::format("Error found in executing display query: %s", exc.displayText()));
		return -1;
	}
	
	//mLog.LogInformation("Closing DB");
	RockDove::ShutdownDB();
	
	return 0;
}



void RockDove::InitDB()
{
        MySQL::Connector::registerConnector();
}


void RockDove::ShutdownDB()
{
        MySQL::Connector::unregisterConnector();
}


RockDoveMailer::RockDoveMailer(const std::string& HostSMTP, 
					Poco::UInt16 SMTPPort, 
					const std::string& Username, 
					const std::string& Password, 
					const std::string& FromAddress, 
					const std::string& SecurityEnabled,
					const std::string& Subject, 
					const std::string& Content) :
//					RockDoveLogger& log) :
					mHostSMTP(HostSMTP),
					mSMTPPort(SMTPPort),
					mUsername(Username),
					mPassword(Password),
					mFromAddress(FromAddress),
					mSecurityEnabled(SecurityEnabled),
					mSubject(Subject),
					mContent(Content)
//					mLog (log)
{
}

RockDoveMailer::~RockDoveMailer()
{
}

class SSLInitializer
{
public:
        SSLInitializer()
        {
                Poco::Net::initializeSSL();
        }
        
        ~SSLInitializer()
        {
                Poco::Net::uninitializeSSL();
        }
};

int RockDoveMailer::SendMail(const std::string mToAddress)
{
		// Preparing message
		//mLog.LogInformation("Preparing message");
		std::string charset = "utf-8";
		std::string contentType = "text/plain; charset=\"utf-8\"";
		mSubject = MailMessage::encodeWord(mSubject, charset);
		
		MailMessage message;
		message.setSender(mFromAddress);
		message.addRecipient(MailRecipient(MailRecipient::PRIMARY_RECIPIENT, mToAddress));
		message.setSubject(mSubject);
		message.setContentType(contentType);
		message.setContent(mContent, MailMessage::ENCODING_8BIT);


		// testing variable SecurityEnabled of rockdove.conf
		//mLog.LogInformation("Testing variable SecutityEnabled of rockdove.conf");
		if(mSecurityEnabled.compare("YES") != 0)
		{
		   try
		   {
				// Establish socket connection with NO security
				//mLog.LogInformation("Establish socket connection with NO security");
				SMTPClientSession session(mHostSMTP, mSMTPPort);
				session.login(SMTPClientSession::AUTH_LOGIN, mUsername, mPassword);
				session.sendMessage(message);
				session.close();
				return 0;
		   }
		   catch (Poco::Exception& exc)
		   {
				std::cout << exc.displayText() << std::endl;
				return -1;
		   }

		}
		else
		{
			   try
			   {
					/*
					Poco::Net::Context::Ptr pContext = new Poco::Net::Context(
					 Poco::Net::Context::CLIENT_USE, 
					 "", 
					 "",
					 "",
					 Poco::Net::Context::VERIFY_NONE
					);
					 
					pContext->enableExtendedCertificateVerification(false);
					Poco::Net::SocketAddress addr(mHostSMTP,mSMTPPort);
					//the following row generates the error:
					//SSL Exception: error:140770FC:SSL routines:SSL23_GET_SERVER_HELLO:unknown protocol
					//Poco::Net::SecureStreamSocket sss(addr, "neverb.net", pContext);
					Poco::Net::SecureStreamSocket sss(addr, pContext);
					Poco::Net::SecureSMTPClientSession session(sss);
					session.startTLS();
					session.login(SecureSMTPClientSession::AUTH_LOGIN, mUsername, mPassword);

					session.sendMessage(message);
					session.close();
					*/
					
					SSLInitializer sslInitializer;
					
					// Note: we must create the passphrase handler prior Context 	
					
					SharedPtr<InvalidCertificateHandler> pCert = new ConsoleCertificateHandler(false); // ask the user via console
					Context::Ptr pContext = new Context(Context::CLIENT_USE, "", "", "", Context::VERIFY_RELAXED, 9, true, "ALL:!ADH:!LOW:!EXP:!MD5:@STRENGTH");
					SSLManager::instance().initializeClient(0, pCert, pContext);					

					//Poco::Net::SSLManager &app = Poco::Net::SSLManager::instance();
					//Poco::Net::initializeSSL();


					Poco::Net::SecureSMTPClientSession session(mHostSMTP, mSMTPPort);
					session.login();
					session.startTLS(pContext);
					session.login(Poco::Net::SMTPClientSession::AUTH_LOGIN, mUsername, mPassword);
					session.sendMessage(message);
					session.close();
					

					
					return 0;
					
			   }
			   catch (Poco::Exception& exc)
			   {
					std::cout << exc.displayText() << std::endl;
					return -1;
			   }
		}
}
	

/*

RockDoveLogger::RockDoveLogger(Logger& c,Logger& f) :
		mConsoleLogger	(c),
		mFileLogger (f)
{
}

RockDoveLogger::~RockDoveLogger()
{
}	

void RockDoveLogger::LogInformation(const std::string& msg)
{
	mConsoleLogger.information(msg);
	mFileLogger.information(msg);
}

void RockDoveLogger::LogError(const std::string& msg)
{
	mConsoleLogger.error(msg);
	mFileLogger.error(msg);
}

void RockDoveLogger::LogWarning(const std::string& msg)
{
	mConsoleLogger.warning(msg);
	mFileLogger.warning(msg);
}

*/

class RockDoveApp: public Application
{
public:
	RockDoveApp(): 
		_helpRequested(false),
		_displayRequested(false),
		HTMLFilename(""),
		ConfFile ("")
	{
	}

protected:		
	void defineOptions(OptionSet& options)
	{
		Application::defineOptions(options);

		options.addOption(
			Option("help", "h", "Display help information on command line arguments.")
				.required(false)
				.repeatable(false)
				.callback(OptionCallback<RockDoveApp>(this, &RockDoveApp::handleHelp)));

		options.addOption(
			Option("display", "v", "Display records in ADDRESS table.")
				.required(false)
				.repeatable(false)
				.callback(OptionCallback<RockDoveApp>(this, &RockDoveApp::handleDisplay)));

		options.addOption(
			Option("inputHTML", "i", "HTML content file.")
				.required(true)
				.repeatable(false)
				.argument("HTMLFilename")
				.callback(OptionCallback<RockDoveApp>(this, &RockDoveApp::handleInputHTML)));

		options.addOption(
			Option("confFile", "c", "SMTP configuration file.")
				.required(true)
				.repeatable(false)
				.argument("ConfFile")
				.callback(OptionCallback<RockDoveApp>(this, &RockDoveApp::handleConfFile)));				
				
	}
	
	void handleHelp(const std::string& name, const std::string& value)
	{
		_helpRequested = true;
		stopOptionsProcessing();
	}
	
	void handleDisplay(const std::string& name, const std::string& value)
	{
		_displayRequested = true;	
		stopOptionsProcessing();
	}

	void handleInputHTML(const std::string& name, const std::string& value)
	{
		HTMLFilename = value;	
	}

	void handleConfFile(const std::string& name, const std::string& value)
	{
		ConfFile = value;	
	}

	
	void displayHelp()
	{
		HelpFormatter helpFormatter(options());
		helpFormatter.setCommand(commandName());
		helpFormatter.setUsage("[-v] -i:<HTMLFile> -c:<ConfFILE>");
		helpFormatter.setHeader("RockDove v0.1. This is a mailer utility that take ah HTML file and send it to address in MySql ROCKDB database.");
		helpFormatter.format(std::cout);
	}
	
	int main(const std::vector<std::string>& args)
	{

		// preparing logging to file and console
		FormattingChannel* pFCConsole = new FormattingChannel(new PatternFormatter("[%s@%p]: %t"));
		pFCConsole->setChannel(new ConsoleChannel);
		pFCConsole->open();

		FormattingChannel* pFCFile = new FormattingChannel(new PatternFormatter("%Y-%m-%d %H:%M:%S.%c %N[%P]:%s:%q:%t"));
		pFCFile->setChannel(new FileChannel("rockdove.log"));
		pFCFile->open();

		Logger& ConsoleLogger = Logger::create("RockDoveLog", pFCConsole, Message::PRIO_INFORMATION);
		Logger& FileLogger    = Logger::create("RockDoveFileLogger", pFCFile, Message::PRIO_INFORMATION);


	
		//RockDoveLogger log(ConsoleLogger, FileLogger);
		////log.LogInformation("RockDove utility running...");
		
		// test if display (-v) is set
		if(_displayRequested)
		{
			std::cout << "Displaying address records in ROCKDB\n" << std::endl;
			////log.LogInformation("Displaying address records in ROCKDB");
			try 
			{
				////log.LogInformation("Connecting to ROCKDB");
				//RockDove r("ROCKDB", log);
				RockDove r("ROCKDB");
				//log.LogInformation("Running display of records");
				r.DisplayRecords();
				
			}
			catch (Poco::Exception& exc)
			{
				//log.LogError("Error in fetching records.");
			}
			
			return Application::EXIT_OK;
		}

		if(_helpRequested)
		{
			//log.LogInformation("Displaying help");
			displayHelp();		
			return Application::EXIT_OK;
		}
		
		// getting configuration
		//log.LogInformation(Poco::format("Getting configuration from file %s", ConfFile));
		
		AutoPtr<PropertyFileConfiguration> pConf;
		pConf = new PropertyFileConfiguration(ConfFile);
		std::string cHostname = pConf->getString("SMTPHostname");
		int cPort = pConf->getInt("SMTPPort");
		std::string cUsername = pConf->getString("Username");
		std::string cPassword = pConf->getString("Password");
		std::string cFromAddress = pConf->getString("FromAddress");
		std::string cSecurityEnabled = pConf->getString("SecurityEnabled");

		// reading content file
		//log.LogInformation(Poco::format("Reading content file %s", HTMLFilename));
		Poco::FileInputStream inStream(HTMLFilename);
		std::string content;
		Poco::StreamCopier::copyToString(inStream, content);

		cout << "Configuration file read with the following definitions:" << endl;
		std::cout << "SMTPHostname = " << cHostname << endl;
		std::cout << "SMTPPort = " << cPort << endl;
		std::cout << "Username = " << cUsername << endl;
		std::cout << "Password = " << cPassword << endl;
		std::cout << "FromAddress = " << cFromAddress << endl;
		std::cout << "SecurityEnabled = " << cSecurityEnabled << endl;
			
		//log.LogInformation("Configuration file read with the following definitions:");	
		//log.LogInformation(Poco::format("\t\tSMTPHostname = %s", cHostname));
		//log.LogInformation(Poco::format("\t\tSMTPPort = %s", cPort));
		//log.LogInformation(Poco::format("\t\tUsername = %s", cUsername));
		//log.LogInformation(Poco::format("\t\tPassword = %s", cPassword));
		//log.LogInformation(Poco::format("\t\tFromAddress = %s", cFromAddress));
		//log.LogInformation(Poco::format("\t\tSecurityEnabled = %s", cSecurityEnabled));
			
		//std::cout << content;
		//RockDoveMailer m(cHostname, cPort, cUsername, cPassword, cFromAddress, cSecurityEnabled, "testSubject", content, log);
		RockDoveMailer m(cHostname, cPort, cUsername, cPassword, cFromAddress, cSecurityEnabled, "testSubject", content);
		//RockDove r("ROCKDB", log);
		RockDove r("ROCKDB");
		r.SendAllMails(m);

		return Application::EXIT_OK;
	}
		
private:
	bool _helpRequested;
	bool _displayRequested;
	std::string HTMLFilename;
	std::string ConfFile;
};


POCO_APP_MAIN(RockDoveApp)





